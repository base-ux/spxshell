#%shebang

SPXGEN_VERSION="6"

#%prolog

#%include sys/msg.shi
#%include sys/pathabs.shi
#%include sys/pathcanon.shi
#%include sys/checkfile.shi

################

# Set variables

: ${SRCFILE:=""}		# Source file
: ${OUTFILE:="/dev/stdout"}	# Default output to stdout

# PSTACK is used as filenames stack for 'process_file' function
# PLIST is used as filenames list of the processed files for '#%ifinclude' directive
# CURFILE is currently processing filename
# CURLINE is currently read line in CURFILE
PSTACK=""
PLIST=""
CURFILE=""
CURLINE=""

####

# Print usage information
usage ()
{
    cat << EOF
Usage: ${PROG} [-o outfile] inputfile
EOF
}

# Print help information
usage_help ()
{
    usage
    cat << EOF

    -o outfile	output file name

    inputfile	input file name
EOF
    exit 0
}

####

# Parse command line options
get_options ()
{
    local _opt=""

    case "$1" in ( '-?' | '-help' | '--help' ) usage_help ;; esac
    while getopts ":o:" _opt ; do
	case "${_opt}" in
	    ( 'o' ) OUTFILE="${OPTARG}" ;;
	    ( ':' )
		err "missing argument for option -- '${OPTARG}'"
		usage
		return 1
		;;
	    ( '?' )
		err "unknown option -- '${OPTARG}'"
		usage
		return 1
		;;
	    (  *  )
		err "no handler for option '${_opt}'"
		return 1
		;;
	esac
    done
    shift $((${OPTIND} - 1))
    if test $# -gt 1 ; then
	err "too many arguments"
	usage
	return 1
    elif test $# -eq 1 ; then
	SRCFILE="$1"
    elif test -z "${SRCFILE}" ; then
	# SRCFILE may be set via environment
	err "mandatory argument missing"
	usage
	return 1
    fi
}

####

# Print output line
output_line ()
{
    printf "%s\n" "$*" >&3
}

####

# Process '#%shebang' directive
do_shebang ()
{
    case "${CURLINE}" in
	( *[[:space:]][![:space:]]* )
	    err "no parameters allowed for '#%shebang' directive"
	    return 1
	    ;;
    esac
    output_line "#!/bin/sh"	# The only option for now
}

# Process '#%prolog' directive
do_prolog ()
{
    local _f=""

    case "${CURLINE}" in
	( *[[:space:]][![:space:]]* )
	    err "no parameters allowed for '#%prolog' directive"
	    return 1
	    ;;
    esac
    _f="$(absolute_path "sys/prolog" "${CURFILE%/*}")"
    if test -f "${_f}" ; then
	process_file "${_f}"
    else
	embed_prolog >&3
    fi
}

# Embedded prolog code
embed_prolog ()
{
    cat << 'EOF'
#%prolog
EOF
}

# Process '#%include' directive
do_include ()
{
    local _f=""

    set -- ${CURLINE##'#%include'}
    if test $# -eq 0 ; then
	err "no parameters set for '#%include' directive"
	return 1
    fi
    for _f in "$@" ; do
	{
	    _f="$(absolute_path "${_f}" "${CURFILE%/*}")"	&&
	    process_file "${_f}"
	} || return 1
    done
}

# Process '#%ifinclude' directive
do_ifinclude ()
{
    local _f=""
    local _cf=""

    set -- ${CURLINE##'#%ifinclude'}
    if test $# -eq 0 ; then
	err "no parameters set for '#%ifinclude' directive"
	return 1
    fi
    for _f in "$@" ; do
	{
	    _f="$(absolute_path "${_f}" "${CURFILE%/*}")"	&&
	    _cf="$(canonical_path "${_f}")"			&&
	    case "|${PLIST}|" in
		( *"|${_cf}|"* ) ;;
		( * ) process_file "${_f}" ;;
	    esac
	} || return 1
    done
}

# Process '#%version' directive
do_version ()
{
    set -- ${CURLINE##'#%version'}
    if test $# -ne 0 ; then
	output_line "# version: $*"
	if test -n "${SPXGEN_VERSION}" ; then
	    output_line "# spxgen version: ${SPXGEN_VERSION}"
	fi
    fi
}

# Examine directive and call handler
do_directive ()
{
    case "${CURLINE}" in
	( '#%shebang'   | '#%shebang'[[:space:]]*   )	do_shebang   || return 1 ;;
	( '#%prolog'    | '#%prolog'[[:space:]]*    )	do_prolog    || return 1 ;;
	( '#%include'   | '#%include'[[:space:]]*   )	do_include   || return 1 ;;
	( '#%ifinclude' | '#%ifinclude'[[:space:]]* )	do_ifinclude || return 1 ;;
	( '#%version'   | '#%version'[[:space:]]*   )	do_version   || return 1 ;;
	( * )
	    err "unknown directive '${CURLINE%%[[:space:]]*}'"
	    return 1
	    ;;
    esac
}

####

# Read file
read_file ()
{
    local _ln=0

    while IFS= read -r CURLINE ; do
	_ln="$(( ${_ln} + 1 ))"
	case "${CURLINE}" in
	    ( '#%'* )
		do_directive ||
		{
		    err "processing error in file '${CURFILE}' at line ${_ln}"
		    return 1
		}
		;;
	    ( * ) output_line "${CURLINE}" ;;
	esac
    done

    # As 'read_file' is executed in subshell there is a way to hand over
    # variables to 'upstream' 'process_file' function
    printf 'PLIST="%s"' "${PLIST}"
}

# Process file
process_file ()
{
    local _file="$1"
    local _cfile=""
    local _ret=""

    # Check file
    check_file "${_file}" || return 1

    # Add canonical file name to stack (for cyclic include determination)
    _cfile="$(canonical_path "${_file}")" || return 1
    case "|${PSTACK}|" in
	( *"|${_cfile}|"* )
	    err "cyclic include of file '${_file}'"
	    return 1
	    ;;
	( * ) PSTACK="${PSTACK:+"${PSTACK}|"}${_cfile}" ;;
    esac

    # Read file
    _ret="$(CURFILE="${_file}" ; cmd cat "${CURFILE}" | read_file)"
    test -n "${_ret}" && eval "${_ret}" || return 1

    # Remove from file names stack
    _cfile="${PSTACK##*"|"}"	# Restore _cfile
    PSTACK="${PSTACK%"${_cfile}"*}"
    PSTACK="${PSTACK%"|"*}"	# Remove trailing bar

    # Add canonical file name to the list of processed files
    # which is used in conditional '#%ifinclude' directive
    case " ${PLIST} " in
	( *"|${_cfile}|"* ) ;;
	( * ) PLIST="${PLIST:+"${PLIST}|"}${_cfile}" ;;
    esac
}

####

# Initialization subroutine
startup ()
{
    SRCFILE="$(absolute_path "${SRCFILE}")"	&&
    OUTFILE="$(absolute_path "${OUTFILE}")"	&&
    exec 3> "${OUTFILE}"
}

# Close output descriptor
cleanup ()
{
    exec 3>&-
}

# Clean up the staff and exit with error
clean_fail ()
{
    cleanup
    cmd rm -f "${OUTFILE}"
    fail "${1:-1}"
}

# Exit with error code
fail ()
{
    exit "${1:-1}"
}

####

# Main subroutine
main ()
{
    get_options "$@" && startup || fail
    trap 'clean_fail 130' HUP INT TERM
    process_file "${SRCFILE}" || clean_fail
    cleanup
}

# Call main subroutine
main "$@"
