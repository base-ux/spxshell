#%shebang

SPXGEN_VERSION="5"

#%prolog

#%include sys/msg.shi
#%include sys/pathabs.shi
#%include sys/pathcanon.shi
#%include sys/checkfile.shi

################

# Set variables

: ${SRCFILE:=""}		# Source file
: ${OUTFILE:="/dev/stdout"}	# Default output to stdout

# RSTACK is used as filenames and line numbers stack for 'read_file' function
# PSTACK is used as filenames stack for 'process_file' function
# PLIST is used as filenames list of the processed files for '#%ifinclude' directive
RSTACK=""
PSTACK=""
PLIST=""

####

# Print usage information
usage ()
{
    cat << EOF
Usage: ${PROG} [-o outfile] inputfile
EOF
}

# Print help information
usage_help ()
{
    usage
    cat << EOF

    -o outfile	output file name

    inputfile	input file name
EOF
    exit 0
}

####

# Parse command line options
get_options ()
{
    local _opt=""

    case "$1" in ( '-?' | '-help' | '--help' ) usage_help ;; esac
    while getopts ":o:" _opt ; do
	case "${_opt}" in
	    ( 'o' ) OUTFILE="${OPTARG}" ;;
	    ( ':' )
		err "missing argument for option -- '${OPTARG}'"
		usage
		return 1
		;;
	    ( '?' )
		err "unknown option -- '${OPTARG}'"
		usage
		return 1
		;;
	    (  *  )
		err "no handler for option '${_opt}'"
		return 1
		;;
	esac
    done
    shift $((${OPTIND} - 1))
    if test $# -gt 1 ; then
	err "too many arguments"
	usage
	return 1
    elif test $# -eq 1 ; then
	SRCFILE="$1"
    elif test -z "${SRCFILE}" ; then
	# SRCFILE may be set via environment
	err "mandatory argument missing"
	usage
	return 1
    fi
}

####

# Print output line
output_line ()
{
    printf "%s\n" "$*" >&3
}

####

# Process '#%shebang' directive
do_shebang ()
{
    local _file="$1"
    local _line="$2"

    case "${_line}" in
	( *[[:space:]][![:space:]]* )
	    err "no parameters allowed for '#%shebang' directive"
	    return 1
	    ;;
    esac
    output_line "#!/bin/sh"	# The only option for now
}

# Process '#%prolog' directive
do_prolog ()
{
    local _file="$1"
    local _line="$2"
    local _f=""

    case "${_line}" in
	( *[[:space:]][![:space:]]* )
	    err "no parameters allowed for '#%prolog' directive"
	    return 1
	    ;;
    esac
    _f="$(absolute_path "sys/prolog" "${_file%/*}")"
    if test -f "${_f}" ; then
	process_file "${_f}"
    else
	embed_prolog >&3
    fi
}

# Embedded prolog code
embed_prolog ()
{
    cat << 'EOF'
#%prolog
EOF
}

# Process '#%include' directive
do_include ()
{
    local _file="$1"
    local _line="$2"
    local _f=""

    set -- ${_line##'#%include'}
    if test $# -eq 0 ; then
	err "no parameters set for '#%include' directive"
	return 1
    fi
    for _f in "$@" ; do
	{
	    _f="$(absolute_path "${_f}" "${_file%/*}")"	&&
	    process_file "${_f}"
	} || return 1
    done
}

# Process '#%ifinclude' directive
do_ifinclude ()
{
    local _file="$1"
    local _line="$2"
    local _f=""
    local _cf=""

    set -- ${_line##'#%ifinclude'}
    if test $# -eq 0 ; then
	err "no parameters set for '#%ifinclude' directive"
	return 1
    fi
    for _f in "$@" ; do
	{
	    _f="$(absolute_path "${_f}" "${_file%/*}")"	&&
	    _cf="$(canonical_path "${_f}")" &&
	    case "|${PLIST}|" in
		( *"|${_cf}|"* ) ;;
		( * ) process_file "${_f}" ;;
	    esac
	} || return 1
    done
}

# Process '#%version' directive
do_version ()
{
    local _file="$1"
    local _line="$2"

    set -- ${_line##'#%version'}
    if test $# -ne 0 ; then
	output_line "# version: $*"
	if test -n "${SPXGEN_VERSION}" ; then
	    output_line "# spxgen version: ${SPXGEN_VERSION}"
	fi
    fi
}

# Examine directive and call handler
do_directive ()
{
    local _file="$1"
    local _line="$2"

    case "${_line}" in
	( '#%shebang' | '#%shebang'[[:space:]]* )
	    do_shebang "${_file}" "${_line}" || return 1 ;;
	( '#%prolog'  | '#%prolog'[[:space:]]*  )
	    do_prolog  "${_file}" "${_line}" || return 1 ;;
	( '#%include' | '#%include'[[:space:]]* )
	    do_include "${_file}" "${_line}" || return 1 ;;
	( '#%ifinclude' | '#%ifinclude'[[:space:]]* )
	    do_ifinclude "${_file}" "${_line}" || return 1 ;;
	( '#%version' | '#%version'[[:space:]]* )
	    do_version "${_file}" "${_line}" || return 1 ;;
	( * )
	    err "unknown directive '${_line%%[[:space:]]*}'"
	    return 1
	    ;;
    esac
}

####

# Read file
read_file ()
{
    local _file="$1"
    local _ln=0
    local _line=""
    local _rc=0

    test -n "${_file}" || return 1
    while IFS= read -r _line ; do
	_ln="$(( ${_ln} + 1 ))"
	case "${_line}" in
	    ( '#%'* )
		# Save file name and line number
		RSTACK="${RSTACK:+"${RSTACK}|"}${_file}:${_ln}"
		# Execute directive
		do_directive "${_file}" "${_line}" ; _rc=$?
		# Restore file name and line number
		_file="${RSTACK##*"|"}"
		RSTACK="${RSTACK%"${_file}"*}"
		RSTACK="${RSTACK%"|"*}"	# Remove trailing bar
		_ln="${_file##*":"}" ; _file="${_file%":"*}"
		# Finally check for error
		if test ${_rc} -ne 0 ; then
		    err "processing error in file '${_file}' at line ${_ln}"
		    return 1
		fi
		;;
	    ( * ) output_line "${_line}" ;;
	esac
    done < "${_file}"
}

# Process file
process_file ()
{
    local _file="$1"
    local _cfile=""

    # Check file
    check_file "${_file}" || return 1

    # Add canonical file name to stack (for cyclic include determination)
    _cfile="$(canonical_path "${_file}")" || return 1
    case "|${PSTACK}|" in
	( *"|${_cfile}|"* )
	    err "cyclic include of file '${_file}'"
	    return 1
	    ;;
	( * ) PSTACK="${PSTACK:+"${PSTACK}|"}${_cfile}" ;;
    esac

    # Read file
    read_file "${_file}" || return 1

    # Remove from file names stack
    _cfile="${PSTACK##*"|"}"	# Restore _cfile
    PSTACK="${PSTACK%"${_cfile}"*}"
    PSTACK="${PSTACK%"|"*}"	# Remove trailing bar

    # Add canonical file name to the list of processed files
    # which is used in conditional '#%ifinclude' directive
    case " ${PLIST} " in
	( *"|${_cfile}|"* ) ;;
	( * ) PLIST="${PLIST:+"${PLIST}|"}${_cfile}" ;;
    esac
}

####

# Initialization subroutine
startup ()
{
    SRCFILE="$(absolute_path "${SRCFILE}")"	&&
    OUTFILE="$(absolute_path "${OUTFILE}")"	&&
    exec 3> "${OUTFILE}"
}

# Close output descriptor
cleanup ()
{
    exec 3>&-
}

# Clean up the staff and exit with error
clean_fail ()
{
    cleanup
    cmd rm -f "${OUTFILE}"
    fail "${1:-1}"
}

# Exit with error code
fail ()
{
    exit "${1:-1}"
}

####

# Main subroutine
main ()
{
    get_options "$@" && startup || fail
    trap 'clean_fail 130' HUP INT TERM
    process_file "${SRCFILE}" || clean_fail
    cleanup
}

# Call main subroutine
main "$@"
