#%shebang
#%version 4

#%prolog

#%include sys/msg
#%include sys/cmd
#%include sys/findcmd
#%include sys/checkfile
#%include sys/checkdir
#%include sys/checkvar
#%include deploy/checksum
#%include deploy/encode
#%include deploy/pack

################

# Set variables

: ${SRCDIR:="$(pwd)"}
: ${OUTDIR:="$(pwd)"}
: ${OUTFILE:="deploy.sh"}
: ${FILELIST:=""}
: ${INITFILE:=""}
: ${PRODUCT:=""}
: ${VERSION:=""}

: ${WORKDIR:=/tmp/${PROG}.$$}

MD5SUM=""

###

# Initialization subroutine
startup ()
{
    local _f=""
    local _flist=""

    # Check binaries
    # Encode
    encode_cmd="$(find_command uuencode base64 openssl)"
    if test -z "${encode_cmd}" ; then
	err "can't find encode binary"
	return 1
    fi
    # Pack
    pack_cmd="$(find_command pax tar)"
    if test -z "${pack_cmd}" ; then
	err "can't find pack binary"
	return 1
    fi
    # MD5 (if there is no MD5 binary then do not check MD5 sum)
    chksum_cmd="$(find_command md5sum openssl)"

    # Check variables
    {
	check_var FILELIST &&
	check_var INITFILE
    } || return 1

    # Normalize output file path
    case "${OUTFILE}" in
	( /* ) OUTDIR="$(dirname -- "${OUTFILE}")" ;;
	(  * ) OUTFILE="${OUTDIR}/${OUTFILE}" ;;
    esac

    # Check directories
    if ! test -d "${SRCDIR}" ; then
	err "directory '${SRCDIR}' doesn't exist"
	return 1
    fi
    if ! test -d "${OUTDIR}" ; then
	err "directory '${OUTDIR}' doesn't exist"
	return 1
    fi

    # Check files and convert to relative paths
    for _f in ${FILELIST} ${INITFILE} ; do
	case "${_f}" in
	    ( /* ) _f="${_f#"${SRCDIR}/"}" ;;
	esac
	check_file "${SRCDIR}/${_f}" || return 1
	_flist="${_flist:+"${_flist} "}${_f}"
    done
    FILELIST="${_flist}"
    INITFILE="${INITFILE#"${SRCDIR}/"}"	# In the case of absolute path

    # Check working directory
    check_dir "${WORKDIR}" || return 1

    # Set working filenames
    W_ARCH="${WORKDIR}/archive.pax"
    W_BLOB="${WORKDIR}/blob"
    W_OUT="${WORKDIR}/out.sh"
}

# Create archive
mkpack ()
{
    if ! pack_${pack_cmd} "${W_ARCH}" "${SRCDIR}" "${FILELIST}" ; then
	err "can't pack file '${W_ARCH}'"
	return 1
    fi
    if test -n "${chksum_cmd}" ; then
	MD5SUM="$(chksum_${chksum_cmd} "${W_ARCH}")"
	MD5SUM="${MD5SUM%%[[:space:]]*}"
    fi
}

# Create blob
mkblob ()
{
    if ! cat "${W_ARCH}" | encode_${encode_cmd} "${W_BLOB}" ; then
	err "can't encode file '${W_ARCH}'"
	return 1
    fi
}

# Generate deploy script
mkdeploy ()
{
    embed_deploy > "${W_OUT}"
}

# Copy generated deploy script
cpdeploy ()
{
    cmd cp "${W_OUT}" "${OUTFILE}"
    if test $? -ne 0 ; then
	err "can't copy file '${W_OUT}' to file '${OUTFILE}'"
	return 1
    fi
}

# Clean working directory
cleanup ()
{
    if test -n "${WORKDIR}" ; then
	cmd rm -f "${W_ARCH}"
	cmd rm -f "${W_BLOB}"
	cmd rm -f "${W_OUT}"
	cmd rmdir "${WORKDIR}"
    fi
}

# Exit with error code
fail ()
{
    exit 1
}

# Clean up the staff and exit with error
clean_fail ()
{
    cleanup
    fail
}

###

usage ()
{
    cat << EOF
Usage: ${PROG} [-d destdir] [-f file]... [-i initfile] [-o outfile] [-s srcdir]
	[-w workdir] [-P product] [-V version]
EOF
}

usage_help ()
{
    usage
    cat << EOF

    -d destdir	where to write output file (default: current directory)
    -f file	file to add to archive (path relative to srcdir)
    -i initfile	init-file to execute by deploy after unpacking
    -o outfile	output file name (either absolute name or relative to destdir)
    -s srcdir	where to look source files (default: current directory)
    -w workdir	where to place temporary working files (default: /tmp)
    -P product	product name to write to deploy file
    -V version	version of product to write to deploy file
EOF
    exit 0
}

get_options ()
{
    local _opt=""

    case "$1" in ( '-?' | '-help' | '--help' ) usage_help ;; esac
    while getopts ":d:f:i:o:s:w:P:V:" _opt ; do
	case "${_opt}" in
	    ( 'd' ) OUTDIR="${OPTARG}"   ;;
	    ( 'i' ) INITFILE="${OPTARG}" ;;
	    ( 'o' ) OUTFILE="${OPTARG}"  ;;
	    ( 's' ) SRCDIR="${OPTARG}"   ;;
	    ( 'w' ) WORKDIR="${OPTARG}"  ;;
	    ( 'P' ) PRODUCT="${OPTARG}"  ;;
	    ( 'V' ) VERSION="${OPTARG}"  ;;
	    ( 'f' ) FILELIST="${FILELIST:+"${FILELIST} "}${OPTARG}" ;;
	    ( ':' )
		err "missing argument for option -- '${OPTARG}'"
		usage
		return 1
		;;
	    ( '?' )
		err "unknown option -- '${OPTARG}'"
		usage
		return 1
		;;
	    (  *  )
		err "no handler for option '${_opt}'"
		return 1
		;;
	esac
    done
    shift $((${OPTIND} - 1))
    if test $# -gt 0 ; then
	err "too many arguments"
	usage
	return 1
    fi
}

###

# Main subroutine
main ()
{
    trap 'cleanup; exit 130' HUP INT TERM
    get_options "$@" && startup || fail
    {
	mkpack   &&
	mkblob   &&
	mkdeploy &&
	cpdeploy
    } || clean_fail
    cleanup
}

#%include deploy/deploy-embed

# Call main subroutine
main "$@"
